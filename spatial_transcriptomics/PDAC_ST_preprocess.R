# This script conducts RCTD in multi mode for deconvolution of ST data (https://github.com/dmcable/spacexr) based on these two articles:
# running RCTD for Visium V1&2: https://raw.githack.com/dmcable/spacexr/master/vignettes/visium_multi.html
# running RCTD for Slide-seq: https://raw.githack.com/dmcable/spacexr/master/vignettes/spatial-transcriptomics.html
# Inputs: scRNA-seq_Data_post_qc.rds (reference) and PDAC_Updated.rds (ST data) from https://zenodo.org/records/10712047
# Outputs: deconv.RData and spatial_matched_PDAC_liver_lymphnode.rds. deconv.RData contains deconvoluted ST data, and 
#         spatial_matched_PDAC_liver_lymphnode.rds is input to scripts/Fig_4/b.R and scripts/ExtFig_3/d.R scripts.
#
# Att.: I ran RCTD in doublet mode for b.R, while here I run it in multi mode. The result of PDAC recurrence
# signature enrichment in doublet mode is better than multi mode (see Fig. 4b and ExtFig. 3d). In general, RCTD works best in doublet mode.

library(Matrix)
library(MatrixGenerics)
library(ggplot2)
library(Seurat)
library(SeuratObject)
library(SeuratDisk)     # Did you 'brew install hdf5'?
library(SeuratWrappers)
library(spacexr)
library(doParallel)
set.seed(42)

if(! file.exists('deconv.RData'))
{
  # STEP 1: Reading in reference scRNAseq data ####
  message('Reading in data')
  
  ## reading in reference scrNAAseq data ####
  
  panc_ = readRDS('scRNA-seq_Data_post_qc.rds')
  DefaultAssay(panc_) = 'RNA'
  
  ## creating reference object ####
  
  # reference needs max 1e4 cells per type (cells with high nCount_RNA should be included)
  ref_ = Reference(counts = panc_[['RNA']]@counts,
                   cell_types = Idents(panc_),
                   nUMI = panc_$nCount_RNA,      # == colSums(panc_[[RNA]]@counts)
                   n_max_cells = 2000)           # max number of cells per cell type; default is 1e4!
  rm(panc_)
  
  # STEP 2: Reading in ST data ####
  
  ## reading in ST data ####
  
  pdac_ = readRDS('PDAC_Updated.rds')     # there are 91,496 spots; 30 histopathological images (slices) and no Visium image!
  DefaultAssay(pdac_) = 'Spatial'
  
  ## extracting spot coordinates for each slice ####
  # each image/slice in a seurat ST object has table coordincates with these columns:
  # tissue: binary indicator (1 or 0) of whether the spot lies on tissue. This is based on the image alignment and tissue detection mask generated by 10x Genomics’ Space Ranger.
  # row: row index of the spot on the Visium hexagonal grid array. These are physical positions on the slide layout, not spatial image coordinates.
  # col: column index of the spot on the Visium grid.
  # imagerow: Y-coordinate (vertical) of the spot in image pixel space (the center of the spot). Used for overlaying transcriptomic data on the histology image (e.g., H&E).
  # imagecol: X-coordinate (horizontal) of the spot in image pixel space.
  
  slices_coords = lapply(X = pdac_@images, FUN =  function(s_)
                                                  {
                                                    coords_ = s_@coordinates[,c("imagerow","imagecol")]
                                                    colnames(coords_) = c('y','x')
                                                    return(coords_)
                                                  })
  names(slices_coords) = NULL
  slices_coords = do.call(slices_coords, what = rbind)      # is it true? all.equal(colnames(pdac_), rownames(slices_coords))
  
  ## creating ST object ####
  # SpatialRNA needs these params to create an ST object:
  # coords: numeric data.frame (or matrix) representing the spatial pixel locations. rownames are barcodes/pixel names, and there should be two columns for ‘x’ and for ‘y’.
  # counts: matrix (or dgCmatrix) representing Digital Gene Expression (DGE). Rownames should be genes and colnames represent barcodes/pixel names. Counts should be untransformed count-level data.
  # nUMI: optional, a named (by pixel barcode) list of total counts or UMI’s appearing at each pixel. If not provided, nUMI will be assumed to be the total counts appearing on each pixel.
  
  st_obj = SpatialRNA(coords = slices_coords,
                      counts = pdac_[['Spatial']]@counts,
                      nUMI = pdac_$nCount_Spatial)      # == colSums(pdac_[['Spatial']]@counts)
  
  plot_puck_continuous(puck = st_obj,
                       barcodes = colnames(st_obj@counts),
                       plot_val = st_obj@nUMI,
                       ylimit = c(0,round(quantile(st_obj@nUMI,0.9))),
                       title ='plot of nUMI')
  rm(pdac_); gc()
  
  # STEP 3: Deconvolution ####
  
  MAX_MULTI_TYPES = 4                                     # default: 4; max number of cell types per pixel (aka spot)
  deconv_ = create.RCTD(spatialRNA = st_obj, reference = ref_,
                        MAX_MULTI_TYPES = MAX_MULTI_TYPES,
                        CONFIDENCE_THRESHOLD = 5,         # default 5; minimum change in likelihood (compared to other cell types) necessary to determine a cell type identity with confidence
                        max_cores = 4)
  deconv_ = run.RCTD(deconv_, doublet_mode = 'multi')     # running in multi mode may take a few hours

  # STEP 4: Filtering results ####
  # (1) in result slot of RCTD object there is an entry for each pixel (aka spot):
        # all_weights: estimated proportion of each cell type
        # cell_type_list: which cell types appear on the pixel; according to MAX_MULTI_TYPES
        # conf_list: which cell types are determined as confident by RCTD according to CONFIDENCE_THRESHOLD
        # sub_weights: normalized estimated proportion of each cell type on the pixel
        # conv_all and conv_sub: pixel (full regression model or greedy subset solution) has converged
  # (2) to comply with doublet mode format, cell type columns and spot class column in multi mode are standardized as follow:
        # (2.1) based on MAX_MULTI_TYPES = 4, there will be max 4 cell types on a spot and therefore 4 columns:
                # first_type: gives the first cell type predicted on the spot
                # second_type: gives the second cell type predicted on the spot
                # third_type: gives the third cell type predicted on the spot
                # fourth_type: gives the fourth cell type predicted on the spot
        # (2.2) spot class is a factor column representing RCTD’s classification in multi mode:
                # reject: no confident cell type
                # singlet: 1 cell type on pixel (spot); uncertain singlet is the same as reject
                # doublet_certain: 2 cell types on pixel
                # doublet_uncertain: 2 cell types on pixel with at most 1 cell type uncertain
                # triplet_certain: 3 cell types on pixel
                # triplet_uncertain: 3 cell types on pixel with at least 1 and at most 2 cell types uncertain
                # quadruplet_certain: 4 cell types on pixel
                # quadruplet_uncertain: 4 cell types on pixel with at least 1 and at most 3 cell types uncertain
  
  min_w = 0.10      # min acceptable proportion of a cell type in a spot
  rslt_ = lapply(X = deconv_@results, FUN = function(s_, min_w)
                                            {
                                              # prop: weight (proportion) of each cell type
                                              # conf: confidence of each cell type
                                              dt_ = data.frame(first_type = NA, second_type = NA, third_type = NA, fourth_type = NA,
                                                               first_type_prop = NA, second_type_prop = NA, third_type_prop = NA, fourth_type_prop = NA,
                                                               first_type_conf = NA, second_type_conf = NA, third_type_conf = NA, fourth_type_conf = NA,
                                                               spot_class = 'reject')
                                              
                                              cells_ = s_$cell_type_list                  # cell types are already in descending order of their weights (proportion)
                                              ws_ = s_$sub_weights
                                              conf_ = s_$conf_list
                                              conf_len = length(which(conf_ %in% T))      # number of confident cell types
                                              if(1 <= conf_len)                           # there must be at least 1 confident cell type on this spot
                                              {
                                                keep_ = which(conf_ | min_w <= ws_)                                             # which cell types are confident, or have min high proportion?
                                                cells_ = cells_[keep_]; ws_ = ws_[keep_]; conf_ = conf_[keep_]
                                                
                                                spot_classe = c('singlet', 'doublet', 'triplet', 'quadruplet')
                                                certainty_ = if(conf_len == length(cells_)){ 'certain' }else{ 'uncertain' }     # uncertain: there's at least 1 uncertain cell type in this multiplet
                                                dt_$spot_class = paste(spot_classe[length(cells_)],certainty_, sep = '_')       # setting spot_class
                                                
                                                for(c_ in 1:length(cells_))
                                                {
                                                  dt_[, c_] = cells_[c_]
                                                  dt_[, c_+MAX_MULTI_TYPES] = ws_[c_]
                                                  dt_[, c_+(2*MAX_MULTI_TYPES)] = conf_[c_]
                                                }
                                              }
                                              return(dt_)
                                            }, min_w = min_w)
  rslt_ = do.call(rslt_, what = rbind)
  rslt_$spot_class[rslt_$spot_class %in% 'singlet_certain'] = 'singlet'
  rslt_$first_type = factor(rslt_$first_type)
  rslt_$second_type = factor(rslt_$second_type)
  rslt_$third_type = factor(rslt_$third_type)
  rslt_$fourth_type = factor(rslt_$fourth_type)
  rslt_$spot_class = factor(rslt_$spot_class, levels = c('singlet',
                                                         'doublet_certain','doublet_uncertain',
                                                         'triplet_certain','triplet_uncertain',
                                                         'quadruplet_certain','quadruplet_uncertain',
                                                         'reject'))
  save(deconv_, rslt_, file = 'deconv.RData')
}else
{
  load('deconv.RData')
}

# STEP 5: Reading in ST data ####

## reading in ST data ####

pdac_ = readRDS('PDAC_Updated.rds')     # there are 91,496 spots; 30 histopathological images (slices) and no Visium image!
DefaultAssay(pdac_) = 'SCT'

## removing unwanted assays ####

pdac_@assays = pdac_@assays["SCT"]

## removing unwanted reductions ####

pdac_@reductions = pdac_@reductions[c("pca","umap.ischia14")]
names(pdac_@reductions)[[2]] = 'umap'

## removing unwanted meta data ####
# seurat and snn: related to seurat clustering
# first, second, conv, score: related to RCTD deconvolution
# ischia and CompositionCluster_CC related to ISCHIA; see PMID: 38225383
# fges: related to functional gene expression signature (Fges) gene sets that is the same as GSEA; see Fig. 1's caption

pdac_@meta.data = pdac_@meta.data[,!grepl(pattern = "(seurat)|(snn)|(first)|(second)|(conv)|(spot_class)|(score)|(ischia)|(CompositionCluster_CC)|(fges)",
                                          x = colnames(pdac_@meta.data),ignore.case = T)]
pdac_@meta.data = cbind(pdac_@meta.data, rslt_)

## plotting results ####

DimPlot(object = pdac_, group.by = 'Histology')+
DimPlot(object = pdac_, group.by = 'first_type')+
DimPlot(object = pdac_, group.by = 'second_type')+
DimPlot(object = pdac_, group.by = 'spot_class')
ggsave(filename = 'ST_TME.pdf', device = 'pdf', width = 15, height = 15, units = 'in')

# STEP 6: Saving ST pdac data ####

pdac_@images = list()
saveRDS(pdac_, file = 'spatial_matched_PDAC_liver_lymphnode.rds')

